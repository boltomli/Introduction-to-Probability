%!PS-Adobe-3.0 EPSF-3.0
%%Creator: Adobe Illustrator(TM) 5.0
%%For: (laurie snell) (dartmouth college)
%%Title: (PSfigappB.ps)
%%CreationDate: (4/8/97) (4:50 PM)
%%BoundingBox: 129 119 492 673
%%HiResBoundingBox: 129.8671 119.9502 491.1961 672.9244
%%DocumentProcessColors: Black
%%DocumentFonts: Helvetica
%%+ Helvetica-Oblique
%%DocumentSuppliedResources: procset Adobe_level2_AI5 1.0 0
%%+ procset Adobe_typography_AI5 1.0 0
%%+ procset Adobe_Illustrator_AI6_vars Adobe_Illustrator_AI6
%%+ procset Adobe_Illustrator_AI5 1.0 0
%AI5_FileFormat 2.1
%AI3_ColorUsage: Black&White
%AI3_TemplateBox: 306 396 306 396
%AI3_TileBox: -59 121 671 673
%AI3_DocumentPreview: Macintosh_ColorPic
%AI5_ArtSize: 792 612
%AI5_RulerUnits: 2
%AI5_ArtFlags: 1 0 0 1 0 0 1 1 0
%AI5_TargetResolution: 800
%AI5_NumLayers: 1
%AI5_OpenToView: -102 540 1 769 472 26 0 1 54 75
%AI5_OpenViewLayers: 7
%%EndComments
%%BeginProlog

% ------------------------------------------------------
%%BeginResource: procset Adobe_level2_AI5 1.2 0
%%Title: (Adobe Illustrator (R) Version 5.0 Level 2 Emulation)
%%Version: 1.2 0
%%CreationDate: (04/10/93) ()
%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)
% ------------------------------------------------------

userdict /Adobe_level2_AI5 23 dict dup begin
	put

% use packed arrays immediately
	% packedarray emulation
	/packedarray where not
	{
		userdict begin
		/packedarray
		{
			array astore readonly
		} bind def
		/setpacking /pop load def
		/currentpacking false def
		end
		0
	} if
	pop

% activate packing now
	userdict /defaultpacking currentpacking put true setpacking


% initialize, terminate
	% note : no binding loop needed here by design

	/initialize
	{
		Adobe_level2_AI5 begin
	} bind def
	/terminate
	{
		currentdict Adobe_level2_AI5 eq
		{
			end
		} if
	} bind def

% mark for later stack clean-up
	mark

% custom color business
	/setcustomcolor where not
	{
		/findcmykcustomcolor
		{
			5 packedarray
		} bind def
		/setcustomcolor
		{
			exch aload pop pop
			4
			{
				4 index mul 4 1 roll
			} repeat
			5 -1 roll pop
			setcmykcolor
		}	% don't bind 'setcmykcolor in this procedure
		def
	} if

%	new version checks for non-numeric version strings (5.0.1 fix bh 10/25/93)
%	/gt38? {version cvx exec} stopped {pop true} {38 gt} ifelse def
	
%	newer version handles errors on clones with cvx or exec which would leave junk on the stack
%	(bh 12/2/93)
	/gt38? mark {version cvr cvx exec} stopped {cleartomark true} {38 gt exch pop} ifelse def

	userdict /deviceDPI 72 0 matrix defaultmatrix dtransform dup mul exch dup mul add sqrt put

% test for Level 2 availability
	userdict /level2?
	systemdict /languagelevel known dup
	{
		pop systemdict /languagelevel get 2 ge
	} if
	put


/level2ScreenFreq		%	halftoneDict level2ScreenFreq screenFreq
{
	begin
		60	% 60 lpi is default
		HalftoneType 1 eq
		{
			pop Frequency
		} if
		HalftoneType 2 eq
		{
			pop GrayFrequency
		} if
		HalftoneType 5 eq
		{
			pop Default level2ScreenFreq
		} if
	end
} bind def

userdict /currentScreenFreq  
	level2? {currenthalftone level2ScreenFreq} {currentscreen pop pop} ifelse put

level2? not
	{
		% LEVEL 1+ EMULATIONS (typesetter/color printer extensions)

		% cmyk => gray conversion emulation
		% note this revision approved by Ed Taft
		% for correcting the out of gamut problem
		% in our current emulations

		% don't bind these guys so 'setgray/currentgray can be overloaded
		/setcmykcolor where not
		{
			% see red book II, pp. 305
			/setcmykcolor
			{
				exch .11 mul add exch .59 mul add exch .3 mul add
				1 exch sub setgray
			} def
		} if

		/currentcmykcolor where not
		{
			/currentcmykcolor
			{
				0 0 0 1 currentgray sub
			} def
		} if


		% LEVEL 2 EMULATIONS

		% setoverprint emulation
		/setoverprint where not
		{
			/setoverprint /pop load def
		} if

		% selectfont emulation
		/selectfont where not
		{
			/selectfont
			{
				exch findfont exch
				dup type /arraytype eq
				{
					makefont
				}
				{
					scalefont
				} ifelse
				setfont
			} bind def
		} if

		% cshow emulation
		/cshow where not
		{
			% {proc} (string)
			/cshow
			{
				[
				0 0 5 -1 roll aload pop
				] cvx bind forall
			} bind def
		} if
	} if

% clean up
	cleartomark

	/anyColor?
	{
		add add add 0 ne
	} bind def

	/testColor
	{
		gsave
		setcmykcolor currentcmykcolor
		grestore
	} bind def

	/testCMYKColorThrough
	{
		testColor anyColor?
	} bind def

	userdict /composite?
	level2?
	{
		gsave 1 1 1 1 setcmykcolor currentcmykcolor grestore
		add add add 4 eq
	}
	{
		1 0 0 0 testCMYKColorThrough
		0 1 0 0 testCMYKColorThrough
		0 0 1 0 testCMYKColorThrough
		0 0 0 1 testCMYKColorThrough
		and and and
	} ifelse
	put

% *** other separation state tests if we're not on a composite page	
	composite? not
	{
		userdict begin
		gsave
		/cyan? 1 0 0 0 testCMYKColorThrough def
		/magenta? 0 1 0 0 testCMYKColorThrough def
		/yellow? 0 0 1 0 testCMYKColorThrough def
		/black? 0 0 0 1 testCMYKColorThrough def
		grestore
		/isCMYKSep? cyan? magenta? yellow? black? or or or def
		/customColor? isCMYKSep? not def
		end
	} if

	end defaultpacking setpacking

%%EndResource

% ------------------------------------------------------
%%BeginResource: procset Adobe_typography_AI5 1.0 1
%%Title: (Typography Operators)
%%Version: 1.0 1
%%CreationDate:(03/26/93) ()
%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)
% ------------------------------------------------------

currentpacking true setpacking
userdict /Adobe_typography_AI5 54 dict dup begin
put
/initialize	% varsDict mainDict initialize -
{
	begin	% begin main procset
	begin	% begin vars procset
	Adobe_typography_AI5 begin
	Adobe_typography_AI5
	{
		dup xcheck
		{
			bind
		} if
		pop pop
	} forall
	end

	% take main and vars off the stack
	end
	end

	Adobe_typography_AI5 begin
} def
/terminate	% - terminate -
{
	currentdict Adobe_typography_AI5 eq
	{
		end
	} if
} def

% [ number value stream [ array for encoding modification ] modifyEncoding ==> [ modified array ]
/modifyEncoding
{
	/_tempEncode exch ddef

	% pointer for sequential encodings
	/_pntr 0 ddef
	{
		% get bottom object
		counttomark -1 roll

		% is it a mark ?
		dup type dup /marktype eq
		{
			% exit
			pop pop exit
		}
		{
			% ... object ... type ....

			% insert if a nametype
			/nametype eq
			{
				% insert the name at _pntr and increment pointer
				_tempEncode /_pntr dup load dup 3 1 roll 1 add ddef 3 -1 roll
				put
			}
			{
				% reset _pntr if it's a number
				/_pntr exch ddef
			} ifelse
		} ifelse
	} loop

	% return the modified encoding
	_tempEncode
} def

/TE	% Set std platform encoding 	% (encoding pairs) TE -
{
	StandardEncoding 256 array copy modifyEncoding
	/_nativeEncoding exch def
} def

% re-define font
% expected arguments
% for 'normal fonts : 
% [ /_Helvetica-Bold/Helvetica-Bold direction fontScript defaultEncoding TZ
%
% for cartographic, pictographic, and expert fonts :
% [ ... number value stream ... /_Symbol/Symbol 
%	direction fontScript defaultEncoding TZ
% for blended fonts w/ default encoding :
% [ /_AdobeSans_20ULig1XCond-Bold/AdobeSans 
%	direction fontScript defaultEncoding [ w0 w1 ... wn ] TZ
% for blended fonts w/ special encoding :
% [ ... number value stream ... /_AdobeSans_20ULig1XCond/AdobeSans 
%	direction fontScript defaultEncoding [ w0 w1 ... wn ] TZ
/TZ
{
	% set weight vector (if present)
	dup type /arraytype eq
	{
		/_wv exch def
	}
	{
		/_wv 0 def
	} ifelse

	% platform dependent coding flag
	/_useNativeEncoding exch def

	% pop fontScript & direction
	pop pop

	% create a new dictionary with length
	% equal to original dictionary length + 2
	% copy all the key/value pairs except FID
	% call makeblended font with the weight values if _wv is an array
	findfont _wv type /arraytype eq
	{
		_wv makeblendedfont
	} if
	dup length 2 add dict

	begin

	% copy all the values but the FID
	% into the new dictionary
	mark exch
	{
		1 index /FID ne
		{
			def
		} if
		cleartomark mark
	} forall
	% discard last mark
	pop

	% define FontName
	/FontName exch def

	% if no re-encoding stream is present
	% then if the base encoding vector of the font
	% is the same as StandardEncoding
	% and the use platform encoding flag is true
	% then install AI platform encoding
	% else leave the base encoding in effect

	counttomark 0 eq
	{
		1 _useNativeEncoding eq
		{
			/Encoding _nativeEncoding def
		} if
		% clean up
		cleartomark
	}
	{
		% custom encoding to be done
		% start off with a copy of the font's standard encoding
		/Encoding load 256 array copy
		modifyEncoding /Encoding exch def
	} ifelse
	FontName currentdict
	end

	% register the new font
	definefont pop
} def

% text painting operators
/tr	% string tr ax ay string 
{
	_ax _ay 3 2 roll
} def
/trj	% string trj cx cy fillchar ax ay string 
{
	_cx _cy _sp _ax _ay 6 5 roll
} def

/a0
{
	/Tx	% text							% textString Tx -
	{
		dup
		currentpoint 3 2 roll
		tr _psf
		newpath moveto
		tr _ctm _pss
	} ddef
	/Tj	% justified text				% textString Tj -
	{
		dup
		currentpoint 3 2 roll
		trj _pjsf
		newpath moveto
		trj _ctm _pjss
	} ddef
} def
/a1
{
	/Tx	% text							% textString Tx -
	{
		dup currentpoint 4 2 roll gsave
		dup currentpoint 3 2 roll
		tr _psf
		newpath moveto
		tr _ctm _pss
		grestore 3 1 roll moveto tr sp
	} ddef
	/Tj	% justified text				% textString Tj -
	{
		dup currentpoint 4 2 roll gsave
		dup currentpoint 3 2 roll
		trj _pjsf
		newpath moveto
		trj _ctm _pjss
		grestore 3 1 roll moveto tr jsp
	} ddef
} def

/e0
{
	/Tx	% text							% textString Tx -
	{
		tr _psf
	} ddef
	/Tj	% justified text				% textString Tj -
	{
		trj _pjsf
	} ddef
} def

/e1
{
	/Tx	% text							% textString Tx -
	{
		dup currentpoint 4 2 roll gsave
		tr _psf
		grestore 3 1 roll moveto tr sp
	} ddef
	/Tj	% justified text				% textString Tj -
	{
		dup currentpoint 4 2 roll gsave
		trj _pjsf
		grestore 3 1 roll moveto tr jsp
	} ddef
} def

/i0
{
	/Tx	% text							% textString Tx -
	{
		tr sp
	} ddef
	/Tj	% justified text				% textString Tj -
	{
		trj jsp
	} ddef
} def

/i1
{
	W N
} def

/o0
{
	/Tx	% text							% textString Tx -
	{
		tr sw rmoveto
	} ddef
	/Tj	% justified text				% textString Tj -
	{
		trj swj rmoveto
	} ddef
} def

/r0
{
	/Tx	% text							% textString Tx -
	{
		tr _ctm _pss
	} ddef
	/Tj	% justified text				% textString Tj -
	{
		trj _ctm _pjss
	} ddef
} def

/r1
{
	/Tx	% text							% textString Tx -
	{
		dup currentpoint 4 2 roll currentpoint gsave newpath moveto
		tr _ctm _pss
		grestore 3 1 roll moveto tr sp
	} ddef
	/Tj	% justified text				% textString Tj -
	{
		dup currentpoint 4 2 roll currentpoint gsave newpath moveto
		trj _ctm _pjss
		grestore 3 1 roll moveto tr jsp
	} ddef
} def

% font operators

% Binding
/To	% begin text 					% bindType To -
{
	pop _ctm currentmatrix pop
} def

/TO	% end text					% TO -
{
	iTe _ctm setmatrix newpath
} def

% Text paths
/Tp	% begin text path				% a b c d tx ty startPt Tp -
{
	pop _tm astore pop _ctm setmatrix
	_tDict begin
	/W
	{
	} def
	/h
	{
	} def
} def

/TP	% end text path					% TP -
{
	end
	iTm 0 0 moveto
} def

% Render mode & matrix operators
/Tr	% begin render					% render Tr - 
{
	_render 3 le
	{
		currentpoint newpath moveto
	} if
	dup 8 eq
	{
		pop 0
	}
	{
		dup 9 eq
		{
			pop 1
		} if
	} ifelse
	dup /_render exch ddef
	_renderStart exch get load exec
} def

/iTm	% internal set text matrix		% - iTm -	(uses _tm as implicit argument)
{
	_ctm setmatrix _tm concat 0 _rise translate _hs 1 scale
} def

/Tm	% set text matrix				% a b c d tx ty Tm -
{
	_tm astore pop iTm 0 0 moveto
} def

/Td	% translate text matrix 		% tx ty Td -
{
	_mtx translate _tm _tm concatmatrix pop iTm 0 0 moveto
} def

/iTe	% end render					% - iTe -
{
	_render -1 eq
	{
	}
	{
		_renderEnd _render get dup null ne
		{
			load exec
		}
		{
			pop
		} ifelse
	} ifelse
	/_render -1 ddef
} def


% Attributes
/Ta	% set alignment					% alignment Ta -
{
	pop
} def

/Tf	% set font name and size		% fontname size Tf -
{
	dup 1000 div /_fScl exch ddef
% was  (bh 11/23/93)
% 	exch findfont exch scalefont setfont
%
	selectfont
} def

/Tl	% set leading					% leading paragraphLeading Tl -
{
	pop
	0 exch _leading astore pop
} def

/Tt	% set user tracking				% userTracking Tt -
{
	pop
} def

/TW	% set word spacing				% minSpace optSpace maxSpace TW -
{
	3 npop
} def

/Tw	% set computed word spacing		% wordSpace Tw
{
	/_cx exch ddef
} def

/TC	% set character spacing			% minSpace optSpace maxSpace TC -
{
	3 npop
} def

/Tc	% set computed char spacing 	% charSpace Tc -
{
	/_ax exch ddef
} def

/Ts	% set super/subscripting (rise)	% rise Ts -
{
	/_rise exch ddef
	currentpoint
	iTm
	moveto
} def

/Ti	% set indentation				% firstStartIndent otherStartIndent stopIndent Ti -
{
	3 npop
} def

/Tz	% set horizontal scaling		% scalePercent Tz -
{
	100 div /_hs exch ddef
	iTm
} def

/TA	% set pairwise kerning			% autoKern TA -
%	autoKern = 0 -> no pair kerning
%			 = 1 -> automatic pair kerning
{
	pop
} def

/Tq	% set hanging quotes			% hangingQuotes Tq -
%	hangingQuotes 	= 0 -> no hanging quotes
%			 		= 1 -> hanging quotes
{
	pop
} def

/Th	% set hyphenation				% hyphenate? limitLines? minLead minTail maxLines Th -
% 	hyphenate?	= 0 -> don't hyphenate
%				= 1 -> do hyphenate
% 	limitLines? = 0 -> no limit
%				= 1 -> limit consecutive hyphenated lines
%	minLead		Closest hyphen to beginning of word (0..n)
% 	minTail		Closest hyphen to end of word (0..n)
% 	maxLines	Maximum number of consecutive hyphenated lines (1..n)
{
	pop pop pop pop pop
} def


% Text Bodies
/TX
{
	pop
} def

% /Tx	% non-justified text			% textString Tx -
% /Tj	% justified text				% textString Tj -

/Tk	% kern							% autoKern kernValue Tk -
%  	autoKern = 0 -> manual kern, = 1 -> auto kern
%	kernValue = kern value in em/1000 space
{
	exch pop _fScl mul neg 0 rmoveto
} def
/TK	% non-printing kern				% autoKern kernValue TK -
{
	2 npop
} def

/T*	% carriage return & line feed	% - T* -
{
	_leading aload pop neg Td
} def

/T*-	% carriage return & negative line feed	% - T*- -
{
	_leading aload pop Td
} def

/T-	% print a discretionary hyphen	% - T- -
{
	% backup the pen position by the letterspacing so that
	% full-justified, auto-hyphenated lines display properly
	% [John Farmer 11/18/95]
	_ax neg 0 rmoveto
	_hyphen Tx
} def

/T+	% discretionary hyphen hyphen	% - T+ -
{
} def

/TR	% reset pattern matrix 			% a b c d tx ty TR -
{
	_ctm currentmatrix pop
	_tm astore pop
	iTm 0 0 moveto
} def

/TS	% special chars					% textString justified TS -
{
	currentfont 3 1 roll
	/_Symbol_ _fScl 1000 mul selectfont
	
	0 eq
	{
		Tx
	}
	{
		Tj
	} ifelse
	setfont
} def

% Tab extensions for 5.5 (Glenn Reid 1/26/94)

/Xb % begin tab definitions			% <unused> tabCount Xb -
{
	pop pop
} def
/Tb /Xb load def

/Xe % one tab stop					% leader(char) decimal(char) type(int) distance Xe -
{
	pop pop pop pop
} def
/Te /Xe load def

/XB % end tab definitions			% - XB -
{
} def
/TB /XB load def

currentdict readonly pop
end
setpacking

%%EndResource

% ------------------------------------------------------
%%BeginProcSet: Adobe_ColorImage_AI6 1.0 0
% ColorImage Emulation and Separation Code for Grayscale, RGB and CMYK images
% Version 1.0 12/25/95
% Copyright (C) 1995-96
% Adobe Systems Incorporated
% All Rights Reserved
% ------------------------------------------------------

userdict /Adobe_ColorImage_AI6 known not
{
	userdict /Adobe_ColorImage_AI6 17 dict put 
} if
userdict /Adobe_ColorImage_AI6 get begin

% ------------------------------------------------------
% Routine Overview
% 
%	String Iterators
%		WalkRGBString (given a single source string, convert each pixel to cmyk and call a proc)
%		WalkCMYKString (given a single source string, get the components and call a proc)
% 
%	Level1 Emulator Routines
%		StuffRGBIntoGrayString
%		RGBToGrayImageProc
%		StuffCMYKIntoGrayString 
%		CMYKToGrayImageProc 
%		ColorImageCompositeEmulator 
% 
%	ColorImage CMYK Separation Hacks (For [Applications] that only support planar images)
%		CMYKToSeparatedCMYKImageProc
% 
%	ColorImage and Utility Routines.
%		FourEqual
%		TestPlateIndex
%		colorimage
% 
% ------------------------------------------------------	

/initialize
{ 
	Adobe_ColorImage_AI6 begin
	Adobe_ColorImage_AI6
	{
		dup type /arraytype eq
		{
			dup xcheck
			{
				bind
			} if
		} if
		pop pop
	} forall
} def

/terminate { end } def

currentdict /Adobe_ColorImage_AI6_Vars known not
{
	/Adobe_ColorImage_AI6_Vars 14 dict def
} if

Adobe_ColorImage_AI6_Vars begin
	/channelcount 0 def
	/sourcecount 0 def
	/sourcearray 4 array def
	/plateindex -1 def
	/XIMask 0 def
	/XIBinary 0 def
	/XIChannelCount 0 def
	/XIBitsPerPixel 0 def
	/XIImageHeight 0 def
	/XIImageWidth 0 def
	/XIImageMatrix null def
	/XIBuffer null def
	/XIDataProc null def
end

/WalkRGBString null def
/WalkCMYKString null def

/StuffRGBIntoGrayString null def
/RGBToGrayImageProc null def
/StuffCMYKIntoGrayString null def
/CMYKToGrayImageProc null def
/ColorImageCompositeEmulator null def

/SeparateCMYKImageProc null def

/FourEqual null def
/TestPlateIndex null def

% define _colorimage if it doesn't already exist
currentdict /_colorimage known not
{
	/colorimage where
	{
		% sourcedictionary (systemdict or a separation proc redefinition)
		/colorimage get /_colorimage exch def
	}
	{
		/_colorimage null def
	} ifelse
} if

/_currenttransfer systemdict /currenttransfer get def

/colorimage null def
/XI null def

% ------------------------------------------------------
% rgb proc out --WalkRGBString--
% ------------------------------------------------------

/WalkRGBString
{
	% rgb proc out
	0 3 index

	% rgb proc out outindex rgb
	dup length 1 sub 0 3 3 -1 roll
	{
		% rgb proc out outindex rgb index
		3 getinterval { } forall

		% call the stuff proc
		% rgb proc out outindex r g b
		5 index exec

		% push rgb for the next loop iteration
		% rgb proc out outindex
		3 index
		% rgb proc out outindex rgb
	} for
	
	% clean up the stack
	% rgb proc out outindex rgb
	 5 { pop } repeat

} def

% ------------------------------------------------------
% cmyk proc gray --WalkCMYKString--
% ------------------------------------------------------

/WalkCMYKString
{
	% cmyk proc gray
	0 3 index

	% cmyk proc gray grayindex cmyk
	dup length 1 sub 0 4 3 -1 roll
	{
		% cmyk proc gray grayindex cmyk index
		4 getinterval { } forall
		
		% cmyk proc gray grayindex c m y k
		6 index exec
		
		% cmyk proc gray grayindex
		3 index
		
		% cmyk proc gray grayindex cmyk
	} for
	
	% clean up the stack
	% cmyk proc gray grayindex cmyk
	5 { pop } repeat
	
} def

% ------------------------------------------------------
% gray grayindex r g b --StuffRGBIntoGrayString-- gray grayindex
% ------------------------------------------------------

/StuffRGBIntoGrayString
{
	% gray grayindex r g b
	.11 mul exch
	
	% gray grayindex r bk g
	.59 mul add exch
	
	% gray grayindex bkgk r
	.3 mul add
	
	% gray grayindex k
	cvi 3 copy put
	
	% gray grayindex k
	pop 1 add
} def

% ------------------------------------------------------
% --RGBToGrayImageProc-- string
% ------------------------------------------------------

/RGBToGrayImageProc
{	
	Adobe_ColorImage_AI6_Vars begin	
		% call the source proc to get the chunky rgb string
		sourcearray 0 get exec

		% make a grayscale string of the same pixel count (ouch, pull me out of this loop)
		% rgb
		dup length 3 idiv string

		% roll off a copy of the gray string
		% rgb gray
		dup 3 1 roll 
		
		% push the stuff proc that we want called by WalkRGBString
		% gray rgb gray
		/StuffRGBIntoGrayString load exch

		% call the rgb conversion iterator
		% gray rgb proc gray
		WalkRGBString

		% return the gray string
		% gray	
	end
} def

% ------------------------------------------------------
% gray grayindex c m y k --StuffCMYKIntoGrayString-- gray grayindex
% ------------------------------------------------------

/StuffCMYKIntoGrayString
{
	% gray grayindex c m y k
	exch .11 mul add
	
	% gray grayindex c m yk
	exch .59 mul add
	
	% gray grayindex c mkyk
	exch .3 mul add
	
	% pin k to 255
	% gray gray index k
	dup 255 gt { pop 255 } if
	
	% gray grayindex k
	255 exch sub cvi 3 copy put
	
	% gray grayindex k
	pop 1 add
} def

% ------------------------------------------------------
% --CMYKToGrayImageProc-- string
% ------------------------------------------------------

/CMYKToGrayImageProc
{	
	Adobe_ColorImage_AI6_Vars begin
		% call the source proc to get the chunky cmyk string
		sourcearray 0 get exec

		% make a grayscale string of the same pixel count (ouch, pull me out of this loop)
		% cmyk
		dup length 4 idiv string

		% roll off a copy of the gray string
		% cmyk gray
		dup 3 1 roll 
		
		% push the stuff proc that we want called by WalkCMYKString
		% gray cmyk gray
		/StuffCMYKIntoGrayString load exch

		% call the cmyk iterator
		% gray cmyk proc gray
		WalkCMYKString

		% return the gray string
		% gray
	end
} def

% ------------------------------------------------------
% width height bitsperpixel matrix firstsource...lastsource multiplesources channelcount --ColorImageCompositeEmulator--
% ------------------------------------------------------

/ColorImageCompositeEmulator
{
	% Channelcount is already saved in Adobe_ColorImage_AI6_Vars. Our data is always in chunky form so punt if someone
	% calls colorimage on a level 1 device with planar data.
	% channelcount and multiplesources are already saved in Adobe_ColorImage_AI6_Vars. The image operator isn't going to use them.
	pop true eq
	{
		% pop off the parameters and return
		Adobe_ColorImage_AI6_Vars /sourcecount get 5 add { pop } repeat
	}
	{
		Adobe_ColorImage_AI6_Vars /channelcount get 1 ne
		{
			Adobe_ColorImage_AI6_Vars begin
				% save off the original chunky source function
				sourcearray 0 3 -1 roll put
			
				% push the appropriate cover proc
				channelcount 3 eq 
				{ 
					/RGBToGrayImageProc 
				}
				{ 
					/CMYKToGrayImageProc
				} ifelse
				load
			end
		} if
		image
	} ifelse
} def

% ------------------------------------------------------
% --SeparateCMYKImageProc-- string
% ------------------------------------------------------

/SeparateCMYKImageProc
{	
	Adobe_ColorImage_AI6_Vars begin

		sourcecount 0 ne
		{
			% planar case: call the source proc for the current plate and return its result
			sourcearray plateindex get exec
		}
		{			
			% call the source proc to get the chunky cmyk string
			sourcearray 0 get exec
			
			% make a grayscale string of the same pixel count (ouch, pull me out of this loop)
			% cmyk
			dup length 4 idiv string
			
			% cmyk
			0 2 index
			
			% cmyk gray grayindex cmyk
			plateindex 4 2 index length 1 sub
			{
				% cmyk gray grayindex cmyk channelindex
				get 255 exch sub
				
				% cmyk gray grayindex grayvalue
				3 copy put pop 1 add
				
				% cmyk gray grayindex
				2 index
			} for

			% return the gray string
			% cmyk gray grayindex cmyk
			pop pop exch pop
		} ifelse
	end
} def
	
% ------------------------------------------------------
% s1 s2 s3 s4 c1 c2 c3 c4 --FourEqual--
% ------------------------------------------------------

/FourEqual
{
	% s1 s2 s3 s4 c1 c2 c3 c4
	4 index ne
	{
		pop pop pop false
	}
	{
		% s1 s2 s3 s4 c1 c2 c3
		4 index ne
		{
			pop pop false
		}
		{
			% s1 s2 s3 s4 c1 c2
			4 index ne
			{
				pop false
			}
			{
				% s1 s2 s3 s4 c1
				4 index eq
			} ifelse
		} ifelse
	} ifelse
} def

% ------------------------------------------------------
%  --TestPlateIndex-- plateindex
% ------------------------------------------------------

/TestPlateIndex
{
	Adobe_ColorImage_AI6_Vars begin
		% assume we're not separating
		/plateindex -1 def

		/setcmykcolor where
		{
			pop
			gsave
			1 0 0 0 setcmykcolor systemdict /currentgray get exec 1 exch sub
			0 1 0 0 setcmykcolor systemdict /currentgray get exec 1 exch sub
			0 0 1 0 setcmykcolor systemdict /currentgray get exec 1 exch sub
			0 0 0 1 setcmykcolor systemdict /currentgray get exec 1 exch sub
			grestore

			% cyan plate?
			1 0 0 0 FourEqual 
			{ 
				/plateindex 0 def
			}
			{
				% magenta plate?
				0 1 0 0 FourEqual
				{ 
					/plateindex 1 def
				}
				{
					% yellow plate?
					0 0 1 0 FourEqual
					{
						/plateindex 2 def
					}
					{
						% black plate
						0 0 0 1 FourEqual
						{ 
							/plateindex 3 def
						}
						{
							0 0 0 0 FourEqual
							{
								/plateindex 5 def
							} if
						} ifelse
					} ifelse
				} ifelse
			} ifelse
			pop pop pop pop
		} if
		plateindex
	end
} def

% ------------------------------------------------------
% width height bitsperpixel matrix firstsource...lastsource multiplesources channelcount --colorimage--
% ------------------------------------------------------

/colorimage
{
	Adobe_ColorImage_AI6_Vars begin
		/channelcount 1 index def
		/sourcecount 2 index 1 eq { channelcount 1 sub } { 0 } ifelse def

		% setup for following if statement
		4 sourcecount add index dup 
		8 eq exch 1 eq or not
	end
	
	% is this not 1 or 8 bit?
	{
		% Call the original proc if the image is at a weird bit depth. This will display a composite if we're separating, but too bad.
		/_colorimage load null ne
		{
			% call the original (they probably punt if we're separating)
			_colorimage
		}
		{
			% pop off the parameters and return
			Adobe_ColorImage_AI6_Vars /sourcecount get
			7 add { pop } repeat
		} ifelse
	}
	{
		% Call the saved colorimage operator if this an rgb, we're printing a composite or we're separating
		% an image to a custom plate. The last case assumes that the separation procs surrounding us
		% take care of punching out
		dup 3 eq
		TestPlateIndex
		dup -1 eq exch 5 eq or or
		{
			% Call the colorimage emulator if we're printing to a level 1 device
			/_colorimage load null eq
			{
				ColorImageCompositeEmulator
			}
			{
				% call image if this is a grayscale so that Quark doesn't die on custom plates
				dup 1 eq
				{
					pop pop image
				}
				{
					% draw to the null device if we're on a custom plate
					Adobe_ColorImage_AI6_Vars /plateindex get 5 eq
					{
						gsave
						
						% stolen from PhotoShop
						0 _currenttransfer exec
						1 _currenttransfer exec
						eq
						{ 0 _currenttransfer exec 0.5 lt }
						{ 0 _currenttransfer exec 1 _currenttransfer exec gt } ifelse
						
						% push the appropriate transfer proc (first case is negative
						% second case is positive) and call settransfer
						{ { pop 0 } } { { pop 1 } } ifelse
						systemdict /settransfer get exec
					} if
					
					_colorimage
					
					% restore from the null device if necessary
					Adobe_ColorImage_AI6_Vars /plateindex get 5 eq
					{
						grestore
					} if
				} ifelse
			} ifelse
		}
		{
			% Are we separating a grayscale image?
			dup 1 eq
			{
				% let the surrounding separation procset handle the separation
				pop pop
				image
			}
			{
				% pop channelcount and multiplesources since they're not used by the image operator
				pop pop

				% Prepare to call the image operator with a cover proc
				Adobe_ColorImage_AI6_Vars begin
					% save off the source procs for our cover proc
					% width height bitsperpixel matrix firstsource...lastsource
					sourcecount -1 0
					{			
						% width height bitsperpixel matrix firstsource...lastsource index
						exch sourcearray 3 1 roll put
					} for

					/SeparateCMYKImageProc load
				end

				% bypass the separation procset since some applications don't handle chunky and the
				% old separator doesn't handle colorimage
				systemdict /image get exec
			} ifelse
		} ifelse
	} ifelse
} def

% ------------------------------------------------------
% --XI--
% ------------------------------------------------------

/XI
{
	Adobe_ColorImage_AI6_Vars begin
		gsave
		/XIMask exch 0 ne def
		/XIBinary exch 0 ne def
		pop
		pop
		/XIChannelCount exch def
		/XIBitsPerPixel exch def
		/XIImageHeight exch def
		/XIImageWidth exch def
		pop pop pop pop
		/XIImageMatrix exch def
		
		XIBitsPerPixel 1 eq
		{
			XIImageWidth 8 div ceiling cvi
		}
		{
			XIImageWidth XIChannelCount mul
		} ifelse
		/XIBuffer exch string def
		
		XIBinary
		{
			/XIDataProc { currentfile XIBuffer readstring pop } def
			% skip the %BeginBinary comment
			currentfile 128 string readline pop pop
		}
		{
			/XIDataProc { currentfile XIBuffer readhexstring pop } def
		} ifelse
		
		0 0 moveto
		XIImageMatrix concat
		XIImageWidth XIImageHeight scale
		
		XIMask
		{
			XIImageWidth XIImageHeight
			false
			[ XIImageWidth 0 0 XIImageHeight neg 0 0 ]
			/XIDataProc load
			
			% synch the PostScript fill with Illustrator's notion of the current fill
			/_lp /null ddef
			_fc
			/_lp /imagemask ddef
			
			imagemask
		}
		{
			XIImageWidth XIImageHeight
			XIBitsPerPixel
			[ XIImageWidth 0 0 XIImageHeight neg 0 0 ]
			/XIDataProc load
			
			% call image if passed grayscale or bitmap data. Some applications
			% die if colorimage is called with gray data.
			XIChannelCount 1 eq
			{
				% Some applications refuse to separate a grayscale image to the black plate if
				% the currentgray is white. Hack around.
				
				gsave
				0 setgray
				
				image
				
				grestore
			}
			{
				false
				XIChannelCount
				colorimage
			} ifelse
		} ifelse

		grestore
	end
} def
	
end

%%EndProcSet

% ------------------------------------------------------
%%BeginResource: procset Adobe_Illustrator_AI5 1.1 0
%%Title: (Adobe Illustrator (R) Version 5.0 Full Prolog)
%%Version: 1.1 0
%%CreationDate: (3/7/1994) ()
%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)
% ------------------------------------------------------

currentpacking true setpacking

% 71 vars, but leave slack of 10 entries for custom Postscript fragments
userdict /Adobe_Illustrator_AI5_vars 81 dict dup begin
put

% paint operands
/_eo false def
/_lp /none def
/_pf
{
} def	% paint fill
/_ps
{
} def	% paint stroke
/_psf
{
} def	% paint string fill
/_pss
{
} def	% paint string stroke
/_pjsf
{
} def	% paint justified string fill
/_pjss
{
} def	% paint justified string stroke
/_pola 0 def
/_doClip 0 def

% paint operators
/cf currentflat def	% - cf flatness

% typography operands
/_tm matrix def
/_renderStart
[
/e0 /r0 /a0 /o0 /e1 /r1 /a1 /i0
] def
/_renderEnd
[
null null null null /i1 /i1 /i1 /i1
] def
/_render -1 def
/_rise 0 def
/_ax 0 def	% x character spacing	(_ax, _ay, _cx, _cy follows awidthshow naming convention)
/_ay 0 def	% y character spacing
/_cx 0 def	% x word spacing
/_cy 0 def	% y word spacing
/_leading
[
0 0
] def
/_ctm matrix def
/_mtx matrix def
/_sp 16#020 def
/_hyphen (-) def
/_fScl 0 def
/_cnt 0 def
/_hs 1 def
/_nativeEncoding 0 def
/_useNativeEncoding 0 def
/_tempEncode 0 def
/_pntr 0 def
/_tDict 2 dict def
/_wv 0 def

% typography operators
/Tx
{
} def
/Tj
{
} def

% compound path operators
/CRender
{
} def

% printing
/_AI3_savepage
{
} def

% color operands
/_gf null def
/_cf 4 array def
/_if null def
/_of false def
/_fc
{
} def
/_gs null def
/_cs 4 array def
/_is null def
/_os false def
/_sc
{
} def

% pattern operands
/_pd 1 dict def
/_ed 15 dict def
/_pm matrix def
/_fm null def
/_fd null def
/_fdd null def
/_sm null def
/_sd null def
/_sdd null def
/_i null def

% discard variables (12 total)

/discardSave null def	% holds save used in discard loop
/buffer 256 string def	% line buffer string : assume 256 chars/line
/beginString null def	% begin delimiter
/endString null def	% end delimiter
/endStringLength null def	% holds buffer size for reading by byte technique
/layerCnt 1 def	% internal variables for discard loop
/layerCount 1 def
/perCent (%) 0 get def
/perCentSeen? false def
/newBuff null def
/newBuffButFirst null def
/newBuffLast null def

% variable for doing clipping without rendering
/clipForward? false def

% end the vars dictionary
end
% =========================================


userdict /Adobe_Illustrator_AI5 known not {
	userdict /Adobe_Illustrator_AI5 91 dict put
} if

userdict /Adobe_Illustrator_AI5 get begin


% initialization
/initialize	% - initialize -
{
	% pushing main on the stack
	Adobe_Illustrator_AI5 dup begin

	% push the vars dictionary
	Adobe_Illustrator_AI5_vars begin

	% at this point the main and vars dictionaries
	% are in the state we wish them to be
	% on exit from the initialize call

	% bind the procedures in the discard dictionary
	discardDict
	{
		bind pop pop
	} forall

	% begin the nc dictionary
	dup /nc get begin

	% bind the procs in main
	{
		% added a test for type = operatortype so procedures like Ln can be defined as an alias for 'pop
		dup xcheck 1 index type /operatortype ne and
		{
			bind
		} if
		pop pop
	} forall

	% turn off 'nc
	end

	newpath

	% on exit we have main and vars on top of dict stack
} def

/terminate	% - terminate -
{
	end
	end
} def

% definition operators
/_	% - _ null
null def
/ddef	% key value ddef -
{
	Adobe_Illustrator_AI5_vars 3 1 roll put
} def
/xput	% key value literal xput -
{
	dup load dup length exch maxlength eq
	{
		dup dup load dup
		length 2 mul dict copy def
	} if
	load begin
	def
	end
} def
/npop	% integer npop -
{
	{
		pop
	} repeat
} def

% marking operators
/sw	% ax ay string sw x y
{
	dup length exch stringwidth
	exch 5 -1 roll 3 index mul add
	4 1 roll 3 1 roll mul add
} def
/swj	% cx cy fillchar ax ay string swj x y
{
	dup 4 1 roll
	dup length exch stringwidth
	exch 5 -1 roll 3 index mul add
	4 1 roll 3 1 roll mul add
	6 2 roll /_cnt 0 ddef
	{
		1 index eq
		{
			/_cnt _cnt 1 add ddef
		} if
	} forall
	pop
	exch _cnt mul exch _cnt mul 2 index add 4 1 roll 2 index add 4 1 roll pop pop
} def
/ss	% ax ay string matrix ss -
{
	4 1 roll
	{
		% matrix ax ay char 0 0 {proc} -
		2 npop
		(0) exch 2 copy 0 exch put pop
		gsave
		false charpath currentpoint
		4 index setmatrix
		stroke
		grestore
		moveto
		2 copy rmoveto
	} exch cshow
	3 npop
} def
/jss	% cx cy fillchar ax ay string matrix jss -
{
	4 1 roll
	{
		% cx cy fillchar matrix ax ay char 0 0 {proc} -   
		2 npop
		(0) exch 2 copy 0 exch put
		gsave
		_sp eq
		{
			exch 6 index 6 index 6 index 5 -1 roll widthshow
			currentpoint
		}
		{
			false charpath currentpoint
			4 index setmatrix stroke
		} ifelse
		grestore
		moveto
		2 copy rmoveto
	} exch cshow
	6 npop
} def

% path operators
/sp	% ax ay string sp -
{
	{
		2 npop (0) exch
		2 copy 0 exch put pop
		false charpath
		2 copy rmoveto
	} exch cshow
	2 npop
} def
/jsp	% cx cy fillchar ax ay string jsp -
{
	{
		% cx cy fillchar ax ay char 0 0 {proc} -
		2 npop
		(0) exch 2 copy 0 exch put
		_sp eq
		{
			exch 5 index 5 index 5 index 5 -1 roll widthshow
		}
		{
			false charpath
		} ifelse
		2 copy rmoveto
	} exch cshow
	5 npop
} def

% path construction operators
/pl	% x y pl x y
{
	transform
	0.25 sub round 0.25 add exch
	0.25 sub round 0.25 add exch
	itransform
} def

/setstrokeadjust where
{
	pop true setstrokeadjust
	/c	% x1 y1 x2 y2 x3 y3 c -
	{
		curveto
	} def
	/C
	/c load def
	/v	% x2 y2 x3 y3 v -
	{
		currentpoint 6 2 roll curveto
	} def
	/V
	/v load def
	/y	% x1 y1 x2 y2 y -
	{
		2 copy curveto
	} def
	/Y
	/y load def
	/l	% x y l -
	{
		lineto
	} def
	/L
	/l load def
	/m	% x y m -
	{
		moveto
	} def
}
{
	% else
	/c
	{
		pl curveto
	} def
	/C
	/c load def
	/v
	{
		currentpoint 6 2 roll pl curveto
	} def
	/V
	/v load def
	/y
	{
		pl 2 copy curveto
	} def
	/Y
	/y load def
	/l
	{
		pl lineto
	} def
	/L
	/l load def
	/m
	{
		pl moveto
	} def
} ifelse

% graphic state operators
/d	% array phase d -
{
	setdash
} def
/cf
{
} def	% - cf flatness
/i	% flatness i -
{
	dup 0 eq
	{
		pop cf
	} if
	setflat
} def
/j	% linejoin j -
{
	setlinejoin
} def
/J	% linecap J -
{
	setlinecap
} def
/M	% miterlimit M -
{
	setmiterlimit
} def
/w	% linewidth w -
{
	setlinewidth
} def

% path painting operators
/XR	% flag XR -
{
	0 ne
	/_eo exch ddef
} def
/H	% - H -
{
} def
/h	% - h -
{
	closepath
} def
/N	% - N -
{
	_pola 0 eq
	{
		_doClip 1 eq
		{
			_eo {eoclip} {clip} ifelse /_doClip 0 ddef
		} if
		newpath
	}
	{
		/CRender
		{
			N
		} ddef
	} ifelse
} def
/n	% - n -
{
	N
} def
/F	% - F -
{
	_pola 0 eq
	{
		_doClip 1 eq
		{
			gsave _pf grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _fc
			/_doClip 0 ddef
		}
		{
			_pf
		} ifelse
	}
	{
		/CRender
		{
			F
		} ddef
	} ifelse
} def
/f	% - f -
{
	closepath
	F
} def
/S	% - S -
{
	_pola 0 eq
	{
		_doClip 1 eq
		{
			gsave _ps grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _sc
			/_doClip 0 ddef
		}
		{
			_ps
		} ifelse
	}
	{
		/CRender
		{
			S
		} ddef
	} ifelse
} def
/s	% - s -
{
	closepath
	S
} def
/B	% - B -
{
	_pola 0 eq
	{
		_doClip 1 eq	% F clears _doClip
		gsave F grestore
		{
			gsave S grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _sc
			/_doClip 0 ddef
		}
		{
			S
		} ifelse
	}
	{
		/CRender
		{
			B
		} ddef
	} ifelse
} def
/b	% - b -
{
	closepath
	B
} def
/W	% - W -
{
	/_doClip 1 ddef
} def
/*	% - [string] * -
{
	count 0 ne
	{
		dup type /stringtype eq
		{
			pop
		} if
	} if
	% used to call newpath only if _polo was 0; now newpath is called unconditionally (bh 3/24/94)
	newpath
} def

% group operators
/u	% - u -
{
} def
/U	% - U -
{
} def
/q	% - q -
{
	_pola 0 eq
	{
		gsave
	} if
} def
/Q	% - Q -
{
	_pola 0 eq
	{
		grestore
	} if
} def
/*u	% - *u -
{
	_pola 1 add /_pola exch ddef
} def
/*U	% - *U -
{
	_pola 1 sub /_pola exch ddef
	_pola 0 eq
	{
		CRender
	} if
} def
/D	% polarized D -
{
	pop
} def
/*w	% - *w -
{
} def
/*W	% - *W -
{
} def

% place operators
/`	% matrix llx lly urx ury string ` -
{
	/_i save ddef

% * special case of clipping forward without rendering
	% use 'nulldevice if true
	clipForward?
	{
		nulldevice
	} if

	6 1 roll 4 npop
	concat pop
	userdict begin
	/showpage
	{
	} def
	0 setgray
	0 setlinecap
	1 setlinewidth
	0 setlinejoin
	10 setmiterlimit
	[] 0 setdash
	/setstrokeadjust where {pop false setstrokeadjust} if
	newpath
	0 setgray
	false setoverprint
} def
/~	% - ~ -
{
	end
	_i restore
} def

% color operators
/O	% flag O -
{
	0 ne
	/_of exch ddef
	/_lp /none ddef
} def
/R	% flag R -
{
	0 ne
	/_os exch ddef
	/_lp /none ddef
} def
/g	% gray g -
{
	/_gf exch ddef
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_gf setgray
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		ashow
	} ddef
	/_pjsf
	{
		_fc
		awidthshow
	} ddef
	/_lp /none ddef
} def
/G	% gray G -
{
	/_gs exch ddef
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_gs setgray
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def
/k	% cyan magenta yellow black k -
{
	_cf astore pop
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_cf aload pop setcmykcolor
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		ashow
	} ddef
	/_pjsf
	{
		_fc
		awidthshow
	} ddef
	/_lp /none ddef
} def
/K	% cyan magenta yellow black K -
{
	_cs astore pop
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_cs aload pop setcmykcolor
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def
/x	% cyan magenta yellow black name gray x -
{
	/_gf exch ddef
	findcmykcustomcolor
	/_if exch ddef
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_if _gf 1 exch sub setcustomcolor
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		ashow
	} ddef
	/_pjsf
	{
		_fc
		awidthshow
	} ddef
	/_lp /none ddef
} def
/X	% cyan magenta yellow black name gray X -
{
	/_gs exch ddef
	findcmykcustomcolor
	/_is exch ddef
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_is _gs 1 exch sub setcustomcolor
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def

% locked object operator
/A	% value A -
{
	pop
} def

% annotate page operator
/annotatepage
{
userdict /annotatepage 2 copy known {get exec} {pop pop} ifelse
} def



% object tag operator
% joe holt November 20, 1994

% /name (value) XT
/XT {
	pop pop
} def


% begin layer PostScript implementation

% general purpose discard loop
% works on early level 1 (v.23, v.38) PostScript printers
% version 0.02 04/03/93
% Bill Woodruff

% constraints :

% if nested discards must be handled
% then the begin and end delimiting
% strings must be of equal length

% arguments

% #nestingFlag
% #nestingFlag = 0  				no nesting
% #nestingFlag = 1  				nesting

% non-nested case
% note : since the non-nested case is invoked
% after the ocurrence of a beginning string
% we only have to look for the ending string
% it is not necessary to specify a beginning string

% 0 (endString) 

% nested case

% (beginString) 1 (endString) 

% the discard procedure is defined in the main dictionary
% it turns the discard dictionary on to execute the discard function
/discard
{
	% test for version, hash a key
	% get and execute the discard procedure from dictionary
	% execute it in a stopped context so we can bail with 'stop
	% wrap it in a save so we don't have to reset variables
	save /discardSave exch store
	discardDict begin
	/endString exch store
	gt38?
	{
		2 add
	} if
	load
	stopped
	pop
	end
	discardSave restore
} bind def

% build the discard dictionary which will contain only procedures
userdict /discardDict 7 dict dup begin
put

% pre 38 initialization
/pre38Initialize
{
	% used as buffer size for reading by byte technique	
	/endStringLength endString length store

	/newBuff buffer 0 endStringLength getinterval store	%	new buffer equal in length to end string
	/newBuffButFirst newBuff 1 endStringLength 1 sub getinterval store	%	pointer to from 2nd to last char in new buffer
	/newBuffLast newBuff endStringLength 1 sub 1 getinterval store	%	pointer to last char in new buffer
} def

% for <=38	
/shiftBuffer
{
	% shift last chars of newBuff to start of newBuff
	newBuff 0 newBuffButFirst putinterval
	% new character into last byte of newBuff
	newBuffLast 0
	currentfile read not
	{
	stop
	} if
	put
} def

% discard procedures

% no nesting, older ps
0
{
	pre38Initialize
	mark
	% fill the buffer
	currentfile newBuff readstring exch pop
	{
		{
			newBuff endString eq
			{
				cleartomark stop
			} if
			shiftBuffer
		} loop
	}
	{
	stop
	} ifelse
} def

% nesting, older ps
1
{
	pre38Initialize

	/beginString exch store

	mark
	currentfile newBuff readstring exch pop
	{
		{
			newBuff beginString eq
			{
				/layerCount dup load 1 add store
			}
			{
				newBuff endString eq
				{
					/layerCount dup load 1 sub store
					layerCount 0 eq
					{
						cleartomark stop
					} if
				} if
			} ifelse

			shiftBuffer
		} loop
	} if
} def

% no nesting, newer ps
2
{
	mark
	{
		% read a line : exit if end of file reached
		currentfile buffer readline not
		{
		stop
		} if

		% end of layer ?
		endString eq
		{
			cleartomark stop
		} if
	} loop
} def

% nesting, newer ps
3
{
	/beginString exch store
	/layerCnt 1 store
	mark
	{
		% read a line : exit if end of file reached
		currentfile buffer readline not
		{
		stop
		} if

		% start of layer ?
		dup beginString eq
		{
			% update layer counter
			pop /layerCnt dup load 1 add store
		}
		{
			% end of layer ?
			endString eq
			{
				% stop if we're not nested
				layerCnt 1 eq
				{
					cleartomark stop
				}
				{
					% nested : decrement layer counter
					/layerCnt dup load 1 sub store
				} ifelse
			} if
		} ifelse
	} loop
} def

% end discard dictionary
end

% define the dictionary for clipping without rendering

userdict /clipRenderOff 15 dict dup begin
put

% flag for marking this dictionary as active
% so we can test in /` and wrap placed
% elements in nulldevice
% /clipForward? true def

% re-define rendering primitives to clip and newpath
% based on value of /_doClip flag
{
	/n /N /s /S /f /F /b /B
}
{
	{
		_doClip 1 eq
		{
			/_doClip 0 ddef _eo {eoclip} {clip} ifelse
		} if
		newpath
	} def
} forall

% modify 'Tr so Tj and Tx are never set up by
% the calls to 'a0, 'e0, etc.
/Tr /pop load def

% special case of 'cshow ?
% is so, we'll have to overload toplevels
% /patternashow /patternawidthshow
% /patternashowstroke
% /patternawidthshowstroke
% /ss /jss /sp /jsp

% perhaps we can bracket out patterns at a higher level ?
% for example, by modifying 'E to pop off its parameters

% call to 'show in 'patternpath ?
% calls to 'ashow in '_psf ?
% calls to 'awidthshow in '_pjsf ?
% calls to 'widthshow in '_jss and '_jsp ?

% disable gradient operators
/Bb {} def
/BB /pop load def
/Bg {12 npop} def
/Bm {6 npop} def
/Bc /Bm load def
/Bh {4 npop} def

% end dictionary for clipping without rendering
end

/Lb	% visible preview enabled printing dimmed masks colorIndex red green blue  ==> Lb
{
	4 npop
	6 1 roll
	pop
	4 1 roll
	pop pop pop

	% #masks #printing 

	% assume that
	% masks = 1 masks forward, masks = 0 no masking or only local masking	

	% do the right thing for printing and masking layer
	0 eq
	{
		% non-printing layer

		0 eq
		{
			% no masking forward from this layer
			% nested discard call
			(%AI5_BeginLayer) 1 (%AI5_EndLayer--) discard
		}
		{
			% masking forward from this layer
			% no printing, but clip path must survive
			
			% set the clipForward? flag in the vars dict
			/clipForward? true def
			
			% redefine Tx and Tj in the vars dict
			/Tx /pop load def
			/Tj /pop load def
			
			% turn on the no rendering dictionary
			currentdict end clipRenderOff begin begin
		} ifelse
	}
	{
		% printing layer

		% encapsulate layer with 'save
		% only if there is no masking forward

		0 eq
		{
			save /discardSave exch store
		} if
	} ifelse
} bind def

% end layer :
% assume that if discardSave is non-null
% then the layer was bracketed by 'save...restore
% else we must test for clipping forward
/LB	% ==> Lb ==> .....
{
	discardSave dup null ne
	{
		% undo the save
		restore
	}
	{
		pop

		clipForward?
		{
			% assume dictionary stack :

			%		vars			
			%		clipRenderOff			
			%		main

			currentdict
			end
			end
			begin

			% dictionary stack :

			%		vars			
			%		main
					
			/clipForward? false ddef

		} if
	} ifelse
} bind def

% begin palette discard
% assume no nesting
/Pb	% topLeftCell selected Pb -
{
	pop pop
	% non nested discard
	0 (%AI5_EndPalette) discard
} bind def

% other type of discard
% assume no nesting
/Np
{
	0 (%AI5_End_NonPrinting--) discard
} bind def

% express layer name
/Ln /pop load def	% ==> Ln ==> .....

% path center-point flag operator
/Ap	% value Ap -
/pop load def

% device-independent flatness
/Ar
{
	72 exch div
	0 dtransform dup mul exch dup mul add sqrt
	dup 1 lt
	{
		pop 1
	} if
	setflat
} def

% multi-layer clipping
/Mb
{
	q
} def
/Md
{
} def
/MB
{
	Q
} def

% null color operators
/nc 3 dict def
nc begin
/setgray	% gray setgray -
{
	pop
} bind def
/setcmykcolor	% cyan magenta yellow black setcmykcolor -
{
	4 npop
} bind def
/setcustomcolor	% object tint setcustomcolor -
{
	2 npop
} bind def
% exit 'nc dictionary
currentdict readonly pop
end

% exit main dictionary
% currentdict readonly pop
end
setpacking

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeFont: Helvetica
%%IncludeFont: Helvetica-Oblique
Adobe_level2_AI5 /initialize get exec
Adobe_Illustrator_AI5_vars Adobe_Illustrator_AI5 Adobe_typography_AI5 /initialize get exec
Adobe_ColorImage_AI6 /initialize get exec
Adobe_Illustrator_AI5 /initialize get exec
[
39/quotesingle 96/grave 128/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis
/Udieresis/aacute/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute
/egrave/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde
/oacute/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex
/udieresis/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/.notdef/AE/Oslash
/.notdef/plusminus/.notdef/.notdef/yen/mu/.notdef/.notdef
/.notdef/.notdef/.notdef/ordfeminine/ordmasculine/.notdef/ae/oslash
/questiondown/exclamdown/logicalnot/.notdef/florin/.notdef/.notdef
/guillemotleft/guillemotright/ellipsis/.notdef/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide
/.notdef/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright
/fi/fl/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex
/Idieresis/Igrave/Oacute/Ocircumflex/.notdef/Ograve/Uacute/Ucircumflex
/Ugrave/dotlessi/circumflex/tilde/macron/breve/dotaccent/ring/cedilla
/hungarumlaut/ogonek/caron
TE
%AI3_BeginEncoding: _Helvetica Helvetica
[/_Helvetica/Helvetica 0 0 1 TZ
%AI3_EndEncoding TrueType
%AI3_BeginEncoding: _Helvetica-Oblique Helvetica-Oblique
[/_Helvetica-Oblique/Helvetica-Oblique 0 0 1 TZ
%AI3_EndEncoding TrueType
%AI5_Begin_NonPrinting
Np
%AI3_BeginPattern: (Yellow Stripe)
(Yellow Stripe) 8.4499 4.6 80.4499 76.6 [
%AI3_Tile
(0 O 0 R 0 0.4 1 0 k 0 0.4 1 0 K) @
(
%AI6_BeginPatternLayer
800 Ar
0 J 0 j 3.6 w 4 M []0 d
%AI3_Note:
0 D
8.1999 8.1999 m
80.6999 8.1999 L
S
8.1999 22.6 m
80.6999 22.6 L
S
8.1999 37.0001 m
80.6999 37.0001 L
S
8.1999 51.3999 m
80.6999 51.3999 L
S
8.1999 65.8 m
80.6999 65.8 L
S
8.1999 15.3999 m
80.6999 15.3999 L
S
8.1999 29.8 m
80.6999 29.8 L
S
8.1999 44.1999 m
80.6999 44.1999 L
S
8.1999 58.6 m
80.6999 58.6 L
S
8.1999 73.0001 m
80.6999 73.0001 L
S
%AI6_EndPatternLayer
) &
] E
%AI3_EndPattern
%AI5_End_NonPrinting--
%AI5_Begin_NonPrinting
Np
3 Bn
%AI5_BeginGradient: (Black & White)
(Black & White) 0 2 Bd
[
<
FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8
D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0
AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A8988
87868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A69686766656463626160
5F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A3938
37363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A19181716151413121110
0F0E0D0C0B0A09080706050403020100
>
0 %_Br
[
0 0 50 100 %_Bs
1 0 50 0 %_Bs
BD
%AI5_EndGradient
%AI5_BeginGradient: (Red & Yellow)
(Red & Yellow) 0 2 Bd
[
0
<
000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F2021222324252627
28292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F
505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F7071727374757677
78797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9F
A0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7
C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF
F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF
>
<
FFFFFEFEFDFDFDFCFCFBFBFBFAFAF9F9F9F8F8F7F7F7F6F6F5F5F5F4F4F3F3F3F2F2F1F1F1F0F0EF
EFEFEEEEEDEDEDECECEBEBEBEAEAE9E9E9E8E8E7E7E7E6E6E5E5E5E4E4E3E3E3E2E2E1E1E1E0E0DF
DFDFDEDEDDDDDDDCDCDBDBDBDADAD9D9D9D8D8D7D7D7D6D6D5D5D5D4D4D3D3D3D2D2D1D1D1D0D0CF
CFCFCECECDCDCDCCCCCBCBCBCACAC9C9C9C8C8C7C7C7C6C6C5C5C5C4C4C3C3C3C2C2C1C1C1C0C0BF
BFBFBEBEBDBDBDBCBCBBBBBBBABAB9B9B9B8B8B7B7B7B6B6B5B5B5B4B4B3B3B3B2B2B1B1B1B0B0AF
AFAFAEAEADADADACACABABABAAAAA9A9A9A8A8A7A7A7A6A6A5A5A5A4A4A3A3A3A2A2A1A1A1A0A09F
9F9F9E9E9D9D9D9C9C9B9B9B9A9A9999
>
0
1 %_Br
[
0 1 0.6 0 1 50 100 %_Bs
0 0 1 0 1 50 0 %_Bs
BD
%AI5_EndGradient
%AI5_BeginGradient: (Yellow & Blue Radial)
(Yellow & Blue Radial) 1 2 Bd
[
<
000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F2021222324252627
28292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F
505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F7071727374757677
78797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9F
A0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7
C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF
F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF
>
<
1415161718191A1B1C1D1E1F1F202122232425262728292A2A2B2C2D2E2F30313233343536363738
393A3B3C3D3E3F40414142434445464748494A4B4C4D4D4E4F50515253545556575858595A5B5C5D
5E5F60616263646465666768696A6B6C6D6E6F6F707172737475767778797A7B7B7C7D7E7F808182
83848586868788898A8B8C8D8E8F90919292939495969798999A9B9C9D9D9E9FA0A1A2A3A4A5A6A7
A8A9A9AAABACADAEAFB0B1B2B3B4B4B5B6B7B8B9BABBBCBDBEBFC0C0C1C2C3C4C5C6C7C8C9CACBCB
CCCDCECFD0D1D2D3D4D5D6D7D7D8D9DADBDCDDDEDFE0E1E2E2E3E4E5E6E7E8E9EAEBECEDEEEEEFF0
F1F2F3F4F5F6F7F8F9F9FAFBFCFDFEFF
>
<
ABAAAAA9A8A7A7A6A5A5A4A3A3A2A1A1A09F9F9E9D9D9C9B9B9A9999989797969595949393929191
908F8F8E8D8D8C8B8B8A8989888787868585848383828181807F7F7E7D7D7C7B7B7A797978777776
7575747373727171706F6F6E6D6D6C6B6B6A6969686767666565646362626160605F5E5E5D5C5C5B
5A5A5958585756565554545352525150504F4E4E4D4C4C4B4A4A4948484746464544444342424140
403F3E3E3D3C3C3B3A3A3938383736363534343332323130302F2E2E2D2C2C2B2A2A292828272626
25242423222121201F1F1E1D1D1C1B1B1A1919181717161515141313121111100F0F0E0D0D0C0B0B
0A090908070706050504030302010100
>
0
1 %_Br
[
0 0.08 0.67 0 1 50 14 %_Bs
1 1 0 0 1 50 100 %_Bs
BD
%AI5_EndGradient
%AI5_End_NonPrinting--
%AI5_BeginPalette
0 4 Pb
Pn
Pc
1 g
Pc
0 g
Pc
0 0 0 0 k
Pc
0.75 g
Pc
0.5 g
Pc
0.25 g
Pc
0 g
Pc
Bb
2 (Black & White) -4014 4716 0 0 1 0 0 1 0 0 Bg
0 BB
Pc
0.25 0 0 0 k
Pc
0.5 0 0 0 k
Pc
0.75 0 0 0 k
Pc
1 0 0 0 k
Pc
0.25 0.25 0 0 k
Pc
0.5 0.5 0 0 k
Pc
0.75 0.75 0 0 k
Pc
1 1 0 0 k
Pc
Bb
2 (Red & Yellow) -4014 4716 0 0 1 0 0 1 0 0 Bg
0 BB
Pc
0 0.25 0 0 k
Pc
0 0.5 0 0 k
Pc
0 0.75 0 0 k
Pc
0 1 0 0 k
Pc
0 0.25 0.25 0 k
Pc
0 0.5 0.5 0 k
Pc
0 0.75 0.75 0 k
Pc
0 1 1 0 k
Pc
Bb
0 0 0 0 Bh
2 (Yellow & Blue Radial) -4014 4716 0 0 1 0 0 1 0 0 Bg
0 BB
Pc
0 0 0.25 0 k
Pc
0 0 0.5 0 k
Pc
0 0 0.75 0 k
Pc
0 0 1 0 k
Pc
0.25 0 0.25 0 k
Pc
0.5 0 0.5 0 k
Pc
0.75 0 0.75 0 k
Pc
1 0 1 0 k
Pc
(Yellow Stripe) 0 0 1 1 0 0 0 0 0 [1 0 0 1 0 0] p
Pc
0.25 0.125 0 0 k
Pc
0.5 0.25 0 0 k
Pc
0.75 0.375 0 0 k
Pc
1 0.5 0 0 k
Pc
0.125 0.25 0 0 k
Pc
0.25 0.5 0 0 k
Pc
0.375 0.75 0 0 k
Pc
0.5 1 0 0 k
Pc
0 0 0 0 k
Pc
0 0.25 0.125 0 k
Pc
0 0.5 0.25 0 k
Pc
0 0.75 0.375 0 k
Pc
0 1 0.5 0 k
Pc
0 0.125 0.25 0 k
Pc
0 0.25 0.5 0 k
Pc
0 0.375 0.75 0 k
Pc
0 0.5 1 0 k
Pc
0 0 0 0 k
Pc
0.125 0 0.25 0 k
Pc
0.25 0 0.5 0 k
Pc
0.375 0 0.75 0 k
Pc
0.5 0 1 0 k
Pc
0.25 0 0.125 0 k
Pc
0.5 0 0.25 0 k
Pc
0.75 0 0.375 0 k
Pc
1 0 0.5 0 k
Pc
0 0 0 0 k
Pc
0.25 0.125 0.125 0 k
Pc
0.5 0.25 0.25 0 k
Pc
0.75 0.375 0.375 0 k
Pc
1 0.5 0.5 0 k
Pc
0.25 0.25 0.125 0 k
Pc
0.5 0.5 0.25 0 k
Pc
0.75 0.75 0.375 0 k
Pc
1 1 0.5 0 k
Pc
0 0 0 0 k
Pc
0.125 0.25 0.125 0 k
Pc
0.25 0.5 0.25 0 k
Pc
0.375 0.75 0.375 0 k
Pc
0.5 1 0.5 0 k
Pc
0.125 0.25 0.25 0 k
Pc
0.25 0.5 0.5 0 k
Pc
0.375 0.75 0.75 0 k
Pc
0.5 1 1 0 k
Pc
0 0 0 0 k
Pc
0.125 0.125 0.25 0 k
Pc
0.25 0.25 0.5 0 k
Pc
0.375 0.375 0.75 0 k
Pc
0.5 0.5 1 0 k
Pc
0.25 0.125 0.25 0 k
Pc
0.5 0.25 0.5 0 k
Pc
0.75 0.375 0.75 0 k
Pc
1 0.5 1 0 k
Pc
PB
%AI5_EndPalette
%%EndSetup
%AI5_BeginLayer
1 1 1 1 0 0 0 79 128 255 Lb
(Layer 1) Ln
0 A
0 To
-0.0011 1 -1 -0.0011 271.2198 122.014 0 Tp
TP
0 Tr
0 O
0 g
800 Ar
0 J 0 j 1 w 4 M []0 d
%AI3_Note:
0 D
/_Helvetica 9 Tf
0 Ts
100 Tz
0 Tt
0 TA
%_ 0 XL
36 0 Xb
XB
0 0 5 TC
100 100 200 TW
0 0 0 Ti
0 Ta
0 0 2 2 3 Th
0 Tq
0 0 Tl
0 Tc
0 Tw
(Above       . .          . .       . .       . .       . .       . .       . .  ) Tx 
(     . .       . .       . .       . .       . .          1        3        . . ) Tx 
(           4               5             . .) Tx
(\r) TX 
0 -11 Td
(    72.5                   . .       . .       . .       . .       . .       . .) Tx 
(       . .         1        2        1        2         7        2         4    ) Tx 
(       19              6           72.2) Tx
(\r) TX 
0 -11 Td
(    71.5                   . .       . .       . .       . .         1        3 ) Tx 
(       4        3        5) Tx 
(      10        4         9        2         2           43             11      ) Tx 
(    69.9) Tx
(\r) TX 
0 -11 Td
(    70.5                     1      . .         1      . .         1        1   ) Tx 
(     3      12      18      14        7         4        3         3           6) Tx 
(8             22          69.5) Tx
(\r) TX 
0 -11 Td
(    69.5                   . .       . .         1      16        4      17     ) Tx 
( 27      20      33      25      20       11        4         5         183     ) Tx 
(        41          68.9  ) Tx
(\r) TX 
0 -11 Td
(    68.5                     ) Tx 
(1      . .         7      11      16      25      31      34      48      21    ) Tx 
(  18         4        3        . .         219             49          68.2) Tx
(\r) TX 
0 -11 Td
(    67.5                   . .         3        5      14      15      36      3) Tx 
(8      28      38      19      11         4       . .        . .         211    ) Tx 
(         33          67.6) Tx
(\r) TX 
0 -11 Td
(    66.5                   . .         3        3        5        2      17     ) Tx 
( 17      14      13        4       . .        . .       . .        . .          ) Tx 
( ) Tx 
(78             20          67.2) Tx
(\r) TX 
0 -11 Td
(    65.5                     1      . .         9        5        7      11     ) Tx 
( 11        7        7        5        2         1       . .        . .          ) Tx 
( 66             12          66.7) Tx
(\r) TX 
0 -11 Td
(    64.5                     1        1        4        4        1        5     ) Tx 
(   5      . .         2      . .        . .        . .       . .        . .     ) Tx 
(      23               5          65.8 ) Tx
(\r) TX 
0 -11 Td
(Below       . .            1       . .        2        4        1        2      ) Tx 
( ) Tx 
( 2        1        1      . .        . .        . .       . .        . .        ) Tx 
(   14               1            . .) Tx
(\r) TX 
0 -11 Td
( ) Tx
(\r) TX 
0 -11 Td
(Totals       . .           5         7      32      59      48    117    138    ) Tx 
(120    167      99      64       41      17       14         928           205  ) Tx 
(          . .) Tx
(\r) TX 
0 -11 Td
(Medians   . .           . .       . .    66.3   67.8   67.9   67.7   67.9   68.3) Tx 
(   68.5    69.0   69.0    70.0     . .        . .            . .              . ) Tx 
(.            . . ) Tx 
(\r) TX 
TO
0 To
-0.0011 1 -1 -0.0011 222.2223 119.9595 0 Tp
TP
0 Tr
(Heights of ) Tx
(\r) TX 
0 -11 Td
(the Mid-parents) Tx
(\r) TX 
0 -11 Td
(in inches.             Below 62.2   63.2   64.2   65.2   66.2   67.2   68.2   69) Tx 
(.2   70.2   71.2   72.2   73.2   Above     children.  ) Tx 
(\r) TX 
TO
0 To
-0.0011 1 -1 -0.0011 203.1412 192.9377 0 Tp
TP
0 Tr
(    Heights of the adult children.) Tx 
(\r) TX 
TO
0 To
-0.0011 1 -1 -0.0011 203.738 554.936 0 Tp
TP
0 Tr
(Total number of) Tx 
(\r) TX 
TO
0 To
-0.0011 1 -1 -0.0011 232.2373 555.4678 0 Tp
TP
0 Tr
(Adult) Tx 
(\r) TX 
TO
0 To
-0.0011 1 -1 -0.0011 231.6921 595.967 0 Tp
TP
0 Tr
(Mid-) Tx
(\r) TX 
0 -11 Td
(parents.) Tx 
(\r) TX 
TO
0 To
-0.0011 1 -1 -0.0011 241.6475 635.9778 0 Tp
TP
0 Tr
(Medians) Tx 
(\r) TX 
TO
211.7402 552.945 m
211.66 624.9445 l
F
212.1334 199.9477 m
211.7523 541.9451 l
F
423.2176 123.1834 m
422.6109 667.8459 l
F
187.2216 120.9621 m
186.6148 665.6246 l
F
0 To
-0.0011 1 -1 -0.0011 171.2218 120.9027 0 Tp
TP
0 Tr
(Number of adult children of various statures born of 205 mid-parents of various ) Tx 
(statures.) Tx
(\r) TX 
0 -11 Td
(\(All female heights have been multiplied by 1.08\)) Tx 
(\r) TX 
TO
0 To
-0.0011 1 -1 -0.0011 445.2164 124.2078 0 Tp
TP
0 Tr
(Note.    In calculating the Medians, the entries have been taken as referring to) Tx 
( the middle of the squares in which they stand.  The reason ) Tx
(\r) TX 
0 -11 Td
(why the headings run 62.2, 63.2, &c., instead of 62.5, 63.5, &c., is that the ob) Tx 
(servations are unequally distributed between 62 and 63, 63 ) Tx
(\r) TX 
0 -11 Td
(and 64, &c., there being a strong bias in favour of integral inches.   After car) Tx 
(eful consideration, I concluded that the h) Tx 
(eadings, as adopted, ) Tx
(\r) TX 
0 -11 Td
(best satisfied the conditions.  This inequality was not apparent in the case of ) Tx 
(the Mid-parents.  Source: F. Galton, "Regression towards ) Tx
(\r) TX 
0 -11 Td
(Mediocrity in Hereditary Stature",  ) Tx 
/_Helvetica-Oblique 9 Tf
(Royal Anthropological Institute of Great Britain and Ireland,) Tx 
/_Helvetica 9 Tf
(  vol.15 \(1885\), p.248.) Tx 
(\r) TX 
TO
250.2192 122.6574 m
249.6125 667.3198 l
F
442.1912 146.7044 m
442.1835 153.7043 l
F
0 R
0 G
152.8885 120.9239 m
152.2817 665.5864 l
B
0 To
-0.0011 1 -1 -0.0011 146.8872 122.2088 0 Tp
TP
2 Tr
/_Helvetica 18 Tf
(Appendix B) Tx 
(\r) TX 
TO
LB
%AI5_EndLayer--
%%PageTrailer
gsave annotatepage grestore showpage
%%Trailer
Adobe_Illustrator_AI5 /terminate get exec
Adobe_ColorImage_AI6 /terminate get exec
Adobe_typography_AI5 /terminate get exec
Adobe_level2_AI5 /terminate get exec
%%EOF
